# lab2
## Cодержание

1. [Отчет по лабораторной работе № 2](#отчет-по-лабораторной-работе--n)
2. [Критерии оценивания](#критерии-оценивания)

## Отчет по лабораторной работе № 2

#### № группы: `ПМ-2402`

#### Выполнила: `Гуськова Анастасия Павловна`

#### Вариант: `8`

### Cодержание:

- [Постановка задачи](#1-постановка-задачи)
- [Входные и выходные данные](#2-входные-и-выходные-данные)
- [Математическая модель](#25-математическая-модель)
- [Выбор структуры данных](#3-выбор-структуры-данных)
- [Алгоритм](#4-алгоритм)
- [Программа](#5-программа)
- [Анализ правильности решения](#6-анализ-правильности-решения)

### 1. Постановка задачи

- Условия задачи

> Создать двумерный массив символов (строчные и заглавные буквы латинского
алфавита) далее:
1. Считать с консоли размеры массива N и M, затем элементы
   массива размером N × M.
2. Сортировать строки массива по убыванию количества заглавных букв
   в строке. Если количество заглавных букв одинаковое, сортировать
   строки по возрастанию количества согласных букв. Если и они равны, сортировать строки по алфавитному порядку символов.
3. Найти и вывести минимальный ASCII-код среди всех символов
   массива, а также символ, которому этот код соответствует.
4. Вывести элементы массива в виде зигзага, начиная с верхнего левого элемента и двигаясь вправо и вниз.
5. Преобразовать все гласные в ‘*’, согласные — в ‘#’ и вывести полученный массив.
- Нужно создать и инициализировать двумерный массив
- Создать переменную для хранения минимального элемента
- Для удобства решения я написала цикл выводящий исходный массив, также инициализировала промежуточный двумерный массив, где строк - 'n',а столбцов - 3 (1-ый столбец: количество заглавных букв;2-ой столбец: количество согласных символов; последний: номер строки в исходном массиве).  
- Обработка промежуточного массива
- Сортировка ромежуточного массива методом пузырька
- Вывод отсортированного массив зигзагом
- Замена символов на соответсвующие заданию элементы и вывод итогового массива

### 2. Входные и выходные данные

Данные на вход:

- На вход программа должна получать 2 целых натуральных числа (первое-количсетво строк и второе-количество элементов в строке). Далее вводятся символы строчные и заглавные буквы латинского
  алфавита.

|               | Тип         | min значение | max значение |
|---------------|-------------|--------------|--------------|
| n (Число 1)   | Целое число | 1            | 2<sup>31     |
| m (Число 2)   | Целое число | 1            | 2<sup>31     |
|(n*m) символов | Символ      | 'A'          | 'z'          |
- символы в промежутке от 'Z' до 'a' не входят.

- На выходе программа будет выдавать строки, целые натуральные числа и символы в диапазоне 'A'-'Z'&&'a'-'z'.

|         | Тип         | min значение | max значение |
|---------|-------------|--------------|--------------|
| Числа   | Целые числа | 1            | 2<sup>31     |
| Строка  | String      |              |              |
| Символы | char        | 'A'          | 'z'          |

### 2,5. Математическая модель

Я не использую никакие формулы или функции, поэтому математическая модель для решения работы мне не нужна.

### 3. Выбор структуры данных

Программа получает 2 целых натуральных числа. Поэтому для их хранения
можно выделить 2 переменных (`n` и `m`) типа `int`.

|                | название переменной | Тип (в Java)  | 
|----------------|---------------------|---------------|
| n (Число 1)    | `n`                 | `int`         |
| m (Число 2)    | `m`                 | `int`         |
| массив         | `massiv`            | `сhar`        |
| minel          | `minel`             | `сhar`        |
| массив         | `masres`            | `int`         |
| массив         | `massiv1`           | `сhar`        |


### 4. Алгоритм

1. **Ввод данных:**  
   Программа считывает два целых числа, обозначенные как n,m. Создается двухмерный массив размером [n][m]. С помощью цикла for массив инициализируется элементами, вводимыми с клавиатуры.

2. **Сортировка:**  
   1. Циклом for перебираем все элементы массива и находим символ с минимальным юникодом
   2. Инициализируем массив-'masres' размерами [n][3]. Заупскаем цикл for для анализа символов строк 'masres', во временные перменные фиксируем значения:в K-количсетво заглавных символов(если элемент входит в диапазон индексов таблицы ASCII от 65-90, прибавляем 1 к перменной), в sogl-количество согласных символов(условным оператором if провряем: если элемент не равен заглавной или строчной буквам a,e,y,u,i,o прибавляем к переменной 1). Далее присваиваем 0,1,2-му элементу текущей строки соответствующие значения.
   3. Начинаем сортировку дополнительног массива-'masres' методом пузырька. Т.к диапазон сортировки столбцов masres всегда уменьшается на 1, то обеспечим это циклом for. Зададим его таким образом, что количество повторений сортировки будет постоянно уменьшаться на 1. Следующим циклом мы анализируем элементы текущей строки(j-ые номера). Цикла в цикле будет достаточно, потому что ячеек для анализа всего три.
   4. Условным оператором if сравниваем первые элементы текущей и следующей строки, если masres[j][0] < masres[j + 1][0] меняем строки местами, если они равны необходимо сравнить вторые элементы строк: если masres[j][1] > masres[j + 1][1], меняем стрки местами, если и они оказались равны, то необходимо запустить цикл for по текущим строкам и разместить их в алфавитном порядке использую юникоды элементов из таблицы ASCII.
3. **Вывод массива зиг-загом**
   1. Запускаем цикл в цикле, где i-строка массива-massiv1, а j-элемент. Если текущий элемент удволетворяет условию: (j==i) или (j==i+1), то выводим этот элемент с пробелом, иначе выводим два пробела.
4. **Замена гласные символов на '*' и согласных на '#'**
   1. Циклом в цикле сравниваем текущий элемент с символами: e,y,u,i,o,a(и такими же но заглавного регистра). В случае равенства заменяем текущий элемент на '*', в обратном случае на '#'.


### 5. Программа

```java
import java.io.PrintStream;
import java.io.IOException;
import java.util.Scanner;
public class racoon {
  public static Scanner in = new Scanner(System.in);
  public static PrintStream out = System.out;

  public static void main(String[] args) throws IOException {
    int n = in.nextInt();
    int m = in.nextInt();
    char [][] massiv = new char[n][m];
    char minel ='{';
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        massiv[i][j] = (char) System.in.read();
        if ((int) minel > (int) massiv[i][j]) {
          minel = massiv[i][j];
        }
      }
    }// инициализация и нахождение самого маленького
    out.println("ASCII-код наименьшего элемента: " + (int) (minel) + "\nНаименьший элемент: " + minel);
    out.println("исходный массив:");
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        out.print(massiv[i][j] + " ");
      }
      out.println();
    } //вывод первого массива
    int[][] masres = new int[n][3];
    for (int i = 0; i < n; i++) {
      int K = 0;
      int sogl = 0;
      for (int j = 0; j < m; j++) {
        if ((int) massiv[i][j] >= (int) 'A' && (int) massiv[i][j] <= (int) 'Z')
          K++;
        if ((int) massiv[i][j] != (int) 'A' && (int) massiv[i][j] != (int) 'E' && (int) massiv[i][j] != (int) 'Y' && (int) massiv[i][j] != (int) 'U' && (int) massiv[i][j] != (int) 'I' && (int) massiv[i][j] != (int) 'O' &&
                (int) massiv[i][j] != (int) 'a' && (int) massiv[i][j] != (int) 'e' && (int) massiv[i][j] != (int) 'y' && (int) massiv[i][j] != (int) 'u' && (int) massiv[i][j] != (int) 'i' && (int) massiv[i][j] != (int) 'o')
          sogl++;
      }
      masres[i][0] = K;
      masres[i][1] = sogl;
      masres[i][2] = i;
    } // инициализация дополнительного массива
    out.println("дополнительный массив:");
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < 3; j++) {
        out.print(masres[i][j] + " ");
      }
      out.println();
    } // вывод дополнительного массива
    for (int i = n - 1; i >= 0; i--) {
      for (int j = 0; j < i; j++) {
        if (masres[j][0] < masres[j + 1][0]) {
          int[] t = masres[j];
          masres[j] = masres[j + 1];
          masres[j + 1] = t;
        }
        if (masres[j][0] == masres[j + 1][0]) {
          if (masres[j][1] > masres[j + 1][1]) {
            int[] t = masres[j];
            masres[j] = masres[j + 1];
            masres[j + 1] = t;
          }
          if (masres[j][1] == masres[j + 1][1]) {
            for (int k = 0; k < m; k++) {
              if ((int) massiv[masres[j][2]][k] != (int) massiv[masres[j + 1][2]][k]) {
                int jj=0;
                int jjj=0;
                if ((int) massiv[masres[j][2]][k] > (int)'a')
                  jj=(int) massiv[masres[j][2]][k]-(int)'a';
                if ((int) massiv[masres[j + 1][2]][k]<(int)'a')
                  jjj=(int) massiv[masres[j + 1][2]][k]-(int)'A';
                if (jj>jjj){
                  int[] t = masres[j];
                  masres[j] = masres[j + 1];
                  masres[j + 1] = t;
                  break;
                }
              }
            }
          }

        }


      }
    } // сортировка дополнительного массива пузырьком

    out.println();

    for (int i = 0; i < n; i++) {
      for (int j = 0; j < 3; j++) {
        out.print(masres[i][j] + " ");
      }
      out.println();
    } // вывод второго массива


    char[][] massiv1 = new char[n][m];
    for (int i = 0; i < n; i++)
      massiv1[i]=massiv[masres[i][2]];
    out.println("отсортированный массив зигзаг:");
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        if ( (j==i) || (j==i+1))
          out.print(massiv1[i][j] + " ");
        else
          out.print("  ");

      }
      out.println();
    }

    for (int i = 0; i < n; i++) {
      for (int j = 0; j <m; j++) {
        if((int) massiv1[i][j] != (int) 'A' && (int) massiv1[i][j] != (int) 'E' && (int) massiv1[i][j] != (int) 'Y' && (int) massiv1[i][j] != (int) 'U' && (int) massiv1[i][j] != (int) 'I' && (int) massiv1[i][j] != (int) 'O' &&
                (int) massiv1[i][j] != (int) 'a' && (int) massiv1[i][j] != (int) 'e' && (int) massiv1[i][j] != (int) 'y' && (int) massiv1[i][j] != (int) 'u' && (int) massiv1[i][j] != (int) 'i' && (int) massiv1[i][j] != (int) 'o'){
          massiv1[i][j]='#';}
        else
          massiv1[i][j]='*';
      }
    }

    out.println("финальный массив:");
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < m; j++) {
        out.print(massiv1[i][j] + " ");
      }
      out.println();
    }
  }
}
```

### 6. Анализ правильности решения
Программа работает верно на всем диапазоне чисел.

1. Одинаковое количсетво заглавных букв

- Input:
    ```
    3 4
    jberSjhbfhrDFekjnf
    ```

- Output:
    ```
    ASCII-код наименьшего элемента: 68
    Наименьший элемент: D
    исходный массив:
    j b e r
    S j h b
    f h r D
    дополнительный массив:
    0 3 0
    1 4 1
    1 4 2

    1 4 2
    1 4 1
    0 3 0
    отсортированный массив зигзаг:
    f h     
      j h   
        e r
    финальный массив:
    # # # # 
    # # # # 
    # # * # 
    ```

2. Одинаковое количество и заглавных букв и согласных букв
- Input:
    ```
    3 4
    DoglVekfVhja
    ```

- Output:
    ```
    ASCII-код наименьшего элемента: 68
    Наименьший элемент: D
    исходный массив:
    D o g l
    V e k f
    V h j a
    дополнительный массив:
    1 3 0
    1 3 1
    1 3 2

    1 3 2
    1 3 1
    1 3 0
    отсортированный массив зигзаг:
    V h     
      e k   
        g l
    финальный массив:
    # # # * 
    # * # # 
    # * # # 
    ```
3. Ничего не одинаковое
- Input:
    ```
    3 4
    DfghghtaFFru
    ```

- Output:
    ```
   ASCII-код наименьшего элемента: 68
   Наименьший элемент: D
   исходный массив:
   D f g h
   g h t a
   F F r u
   дополнительный массив:
   1 4 0
   0 3 1
   2 3 2

   2 3 2
   1 4 0
   0 3 1
   отсортированный массив зигзаг:
   F F     
     f g   
       t a
   финальный массив:
   # # # * 
   # # # # 
   # # # * 
    ```
# Критерии оценивания

Обратите внимание на то, что лабораторная работа должна быть выложена в отдельный репозиторий с названием LabN (N -
Номер лабы). В репозитории должно быть минимум 2 файла (README.md - отчет, Main.java - код лабы)

| **Критерий**                                                                                                                                                                           | **Баллы**       |
|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------|
| **Корректность программы**                                                                                                                                                             | **0** - **40**  |
| - Программа полностью выполняет задачу                                                                                                                                                 | 15              |
| - Нет ошибок выполнения                                                                                                                                                                | 10              |
| - Учтены все ограничения                                                                                                                                                               | 5               |
| - Правильное поведение в "крайних" случаях                                                                                                                                             | 10              |
|                                                                                                                                                                                        |                 |
| **Оптимизация кода**                                                                                                                                                                   | **0** - **20**  |
| - Эффективные алгоритмы                                                                                                                                                                | 10              |
| - Избежание избыточности и повторов                                                                                                                                                    | 5               |
| - Разумность использования структур данных                                                                                                                                             | 5               |
|                                                                                                                                                                                        |                 |
| **Читабельность и стиль кода**                                                                                                                                                         | **0** - **20**  |
| - Соблюдение стандартов форматирования                                                                                                                                                 | 5               |
| - Наличие комментариев, в полном объеме поясняющих написанный код                                                                                                                      | 10              |
| - Понятные имена переменных и функций                                                                                                                                                  | 5               |
|                                                                                                                                                                                        |                 |
| **Оформление отчета**                                                                                                                                                                  | **0** - **20**  |
| - Соблюдение структуры отчета                                                                                                                                                          | 5               |
| - Отчет загружен на GitHub в репозиторий с названием LabN (N - номер лабораторной работы), отчет в формате Markdown с названием README.md, также есть файл Main.java с кодом программы | Обязательно     |
| - Четкое описание алгоритма (блок-схема если нужна)                                                                                                                                    | 5               |
| - Полнота покрытия тестами всех случаев                                                                                                                                                | 5               |
| - Обоснования использования алгоритма, структур данных                                                                                                                                 | 5               |
|                                                                                                                                                                                        |                 |
| **Общая сумма**                                                                                                                                                                        | **0** - **100** |

